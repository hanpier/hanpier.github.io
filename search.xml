<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>k-Fold交叉验证代码</title>
    <url>/2023/02/09/23-44-15/</url>
    <content><![CDATA[<h3 id="k-fold交叉验证代码">1. k-Fold交叉验证代码</h3>
<p>k-Fold交叉验证是一种在机器学习中常用的验证模型性能的方法。它将训练数据集分为k个大小相似的互不重叠的子集，每个子集验证一次，最终验证结果是k次验证结果的平均值。</p>
<p>以下是使用python实现的k-Fold交叉验证代码：</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">learning_function</span>(<span class="params">train_data</span>):</span><br><span class="line">    <span class="comment"># 模拟学习函数，实际应用中请根据实际需求实现学习函数</span></span><br><span class="line">    <span class="keyword">return</span> train_data.mean()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">model, test_data</span>):</span><br><span class="line">    <span class="comment"># 模拟评估函数，实际应用中请根据实际需求实现评估函数</span></span><br><span class="line">    <span class="keyword">return</span> (model - test_data.mean()) ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">KFoldCV</span>(<span class="params">D, A, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    k-fold 交叉验证</span></span><br><span class="line"><span class="string">    参数说明：</span></span><br><span class="line"><span class="string">    D：给定数据集</span></span><br><span class="line"><span class="string">    A：学习函数</span></span><br><span class="line"><span class="string">    k：折数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(D)</span><br><span class="line">    performance = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        test_data = D[<span class="built_in">int</span>(i * n / k) : <span class="built_in">int</span>((i + <span class="number">1</span>) * n / k)]</span><br><span class="line">        train_data = np.concatenate((D[: <span class="built_in">int</span>(i * n / k)], D[<span class="built_in">int</span>((i + <span class="number">1</span>) * n / k) :]), axis=<span class="number">0</span>)</span><br><span class="line">        model = A(train_data)</span><br><span class="line">        p = evaluate(model, test_data)</span><br><span class="line">        performance.append(p)</span><br><span class="line">    <span class="keyword">return</span> np.mean(performance)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成随机数据</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">data = np.random.rand(<span class="number">100</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 进行 k 折交叉验证</span></span><br><span class="line">performance = KFoldCV(data, learning_function, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;平均误差：&quot;</span>, performance)</span><br></pre></td></tr></table></figure>
<h3 id="np.concatenate函数">2. np.concatenate函数</h3>
<p>np.concatenate是numpy库中的函数，用于将多个数组拼接起来。它的参数有两个：</p>
<ol type="1">
<li>arrays：要拼接的数组的列表</li>
<li>axis：拼接方向，0表示按行拼接，1表示按列拼接</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array1 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">array2 = np.array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">array3 = np.array([[<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>], [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿轴 0 连接（按行）</span></span><br><span class="line">result = np.concatenate((array1, array2, array3), axis=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Concatenation along axis 0: \n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿轴 1 连接（按列）</span></span><br><span class="line">result = np.concatenate((array1, array2, array3), axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Concatenation along axis 1: \n&quot;</span>, result)</span><br></pre></td></tr></table></figure>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">沿轴<span class="number"> 0 </span>连接: </span><br><span class="line"> [[<span class="number"> 1 </span><span class="number"> 2 </span> 3]</span><br><span class="line"> [<span class="number"> 4 </span><span class="number"> 5 </span> 6]</span><br><span class="line"> [<span class="number"> 7 </span><span class="number"> 8 </span> 9]</span><br><span class="line"> [10<span class="number"> 11 </span>12]</span><br><span class="line"> [13<span class="number"> 14 </span>15]</span><br><span class="line"> [16<span class="number"> 17 </span>18]]</span><br><span class="line">沿轴<span class="number"> 1 </span>连接: </span><br><span class="line"> [[<span class="number"> 1 </span><span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 7 </span><span class="number"> 8 </span><span class="number"> 9 </span>13<span class="number"> 14 </span>15]</span><br><span class="line"> [<span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span>10<span class="number"> 11 </span>12<span class="number"> 16 </span>17 18]]</span><br></pre></td></tr></table></figure>
<h3 id="np.random.rand">3. np.random.rand</h3>
<p>Numpy中提供了多种生成随机数的函数，主要包括以下几种：</p>
<ul>
<li><p>np.random.rand: 生成[0, 1)范围内的均匀分布随机数</p></li>
<li><p>np.random.randn: 生成标准正态分布随机数</p></li>
<li><p>np.random.randint: 生成给定范围内的整数随机数</p></li>
<li><p>np.random.choice: 从给定的一维数组中随机选取数据</p></li>
<li><p>np.random.permutation: 对给定的一维数组进行随机排列</p></li>
</ul>
<p>在使用这些函数时，通过np.random.seed(0)可以设置随机数生成的种子，使得每次生成的随机数都相同。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 生成 [0, 1) 之间的随机数</span></span><br><span class="line">result = np.random.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rand: \n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 [0, 1) 之间的均匀分布随机数</span></span><br><span class="line">result = np.random.rand(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rand: \n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成正态分布的随机数</span></span><br><span class="line">result = np.random.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;randn: \n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指定区间内的随机整数</span></span><br><span class="line">result = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;randint: \n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指定形状的随机数组，并从给定的一维数组中随机选择元素</span></span><br><span class="line">array = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">result = np.random.choice(array, size=(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;choice: \n&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成指定形状的随机数组，并从给定的一维数组中随机选择元素，可以重复</span></span><br><span class="line">result = np.random.choice(array, size=(<span class="number">2</span>, <span class="number">3</span>), replace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;choice with replacement: \n&quot;</span>, result)</span><br></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">rand: </span><br><span class="line"> <span class="string">[[0.31179588 0.69634349 0.37775184]</span></span><br><span class="line"><span class="string"> [0.17960368 0.02467873 0.06724963]]</span></span><br><span class="line">rand: </span><br><span class="line"> <span class="string">[[0.67939277 0.45369684 0.53657921]</span></span><br><span class="line"><span class="string"> [0.89667129 0.99033895 0.21689698]]</span></span><br><span class="line">randn: </span><br><span class="line"> <span class="string">[[-1.22543552  0.84436298 -1.00021535]</span></span><br><span class="line"><span class="string"> [-1.5447711   1.18802979  0.31694261]]</span></span><br><span class="line">randint: </span><br><span class="line"> <span class="string">[[7 0 3]</span></span><br><span class="line"><span class="string"> [8 7 7]]</span></span><br><span class="line">choice: </span><br><span class="line"> <span class="string">[[6 3 2]</span></span><br><span class="line"><span class="string"> [1 5 1]]</span></span><br><span class="line">choice with replacement: </span><br><span class="line"> <span class="string">[[4 5 5]</span></span><br><span class="line"><span class="string"> [2 1 3]]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>从Autoencoder到beta-VAE</title>
    <url>/2023/04/24/19-17-24/</url>
    <content><![CDATA[<p>https://lilianweng.github.io/posts/2018-08-12-vae/#reparameterization-trick 中文翻译</p>
<h1 id="从autoencoder到beta-vae">从Autoencoder到beta-VAE</h1>
<p>Autoencoder是一个为了使用中间有一个狭窄的bottleneck的神经网络模型重建高维数据而发明的（对于Varaitional Autoencoder可能不是这样的，我们将在后面的章节中详细研究它）。一个很好的副产品是降维：bottleneck层捕获了压缩的潜在编码。这样的低维表示可以用作各种应用（即搜索中的嵌入向量），帮助数据压缩，或者揭示潜在的数据生成因素。</p>
<span id="more"></span>
<h2 id="notions">Notions</h2>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td>数据集，<span class="math inline">\(\mathcal{D}=\left\{\mathbf{x}^{(1)}, \mathbf{x}^{(2)}, \ldots, \mathbf{x}^{(n)}\right\}\)</span>,包括<span class="math inline">\(n\)</span>个数据样本；<span class="math inline">\(\mid \mathcal{D}\mid=n\)</span>.</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\mathbf{x^{i}}\)</span></td>
<td>每个数据点是一个<span class="math inline">\(d\)</span>维的向量，<span class="math inline">\(\mathbf{x}^{(i)}=\left[x_1^{(i)}, x_2^{(i)}, \ldots, x_d^{(i)}\right]\)</span>.</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\mathbf{x}\)</span></td>
<td>数据集中的一个样本，<span class="math inline">\(\mathbf{x}\in\mathcal{D}\)</span>.</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\mathbf{x^{\prime}}\)</span></td>
<td><span class="math inline">\(\mathbf{x}\)</span>的重建版本</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\tilde{\mathbf{x}}\)</span></td>
<td><span class="math inline">\(\mathbf{x}\)</span>的损坏版本</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\mathbf{z}\)</span></td>
<td>bottleneck层学到的压缩编码</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(a_j^{(l)}\)</span></td>
<td>第 <span class="math inline">\(l\)</span> 个隐藏层中第 <span class="math inline">\(j\)</span>个神经元的激活函数</td>
</tr>
<tr class="even">
<td><span class="math inline">\(g_\phi(.)\)</span></td>
<td>以<span class="math inline">\(\phi\)</span>为参数的<strong><em>编码</em></strong>函数</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(f_\theta(.)\)</span></td>
<td>以<span class="math inline">\(\theta\)</span>为参数的<strong><em>解码</em></strong>函数</td>
</tr>
<tr class="even">
<td><span class="math inline">\(q_{\phi}\mathbf{(z\mid x)}\)</span></td>
<td>估计后验概率函数，也称为<strong><em>概率编码器</em></strong>.</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(p_{\theta}\mathbf{(z\mid x})\)</span></td>
<td>给定潜在代码生成真实数据样本的可能性，也称为<strong><em>概率解码器</em></strong>.</td>
</tr>
</tbody>
</table>
<h2 id="autoencoder">Autoencoder</h2>
<p><strong><em>Autoencoder</em></strong>是一种神经网络，旨在以无监督的方式学习一个恒等函数，以重建原始输入，同时在这个过程中压缩数据，从而发现一个更有效和压缩的表示。这个想法起源于20世纪80年代，后来被<a href="https://www.science.org/doi/full/10.1126/science.1127647">Hinton&amp;Salakhutdinov, 2006</a>的开创性论文所推广。</p>
<p>它由两个网络组成：</p>
<ul>
<li><p><strong><em>Encoder network</em></strong>：它将原始的高维输入转变成成潜在的低维编码。输入的尺寸比输出的尺寸大。</p></li>
<li><p><strong><em>Decoder network</em></strong>：解码器网络从编码中恢复数据，可能会有越来越大的输出层。</p></li>
</ul>
<img src="/2023/04/24/19-17-24/autoencoder-architecture.png" class="" title="autoencoder-architecture">
<center>
图1. 自动编码器模型结构的说明
</center>
<p>编码器网络本质上完成了降维，就像我们如何使用主成分分析（PCA）或矩阵分解（MF)一样。此外，自动编码器针对编码的数据重建进行了显式优化。一个好的中间表示不仅可以捕获潜在变量，而且有利于全面的解压过程。</p>
<p>该模型包含以<span class="math inline">\(\phi\)</span>为参数的编码器函数<span class="math inline">\(g(.)\)</span>，并有以<span class="math inline">\(\theta\)</span>为参数的解码器函数<span class="math inline">\(f(.)\)</span>。在bottleneck层为输入<span class="math inline">\(\mathbf{x}\)</span>学习的低维编码是<span class="math inline">\(\mathbf{z}=g_\phi(\mathbf{x})\)</span>，重建的输入是<span class="math inline">\(\mathbf{x}^{\prime}=f_\theta\left(g_\phi(\mathbf{x})\right)\)</span>。</p>
<p>参数<span class="math inline">\((\theta, \phi)\)</span>被一起学习，以输出一个与原始输入相同的重建数据样本，<span class="math inline">\(\mathbf{x} \approx f_\theta\left(g_\phi(\mathbf{x})\right)\)</span>，或者换句话说，学习恒等函数。有各种指标来量化两个向量之间的差异，例如激活函数为sigmoid时的交叉熵，或者简单的MSE损失： <span class="math display">\[
L_{\mathrm{AE}}(\theta, \phi)=\frac{1}{n} \sum_{i=1}^n\left(\mathbf{x}^{(i)}-f_\theta\left(g_\phi\left(\mathbf{x}^{(i)}\right)\right)\right)^2
\]</span></p>
<h2 id="denoising-autoencoder">Denoising Autoencoder</h2>
<p>由于autoencoder学习恒等函数，当网络参数多于数据点时，我们面临“过度拟合”的风险。</p>
<p>为了避免过度拟合并提高鲁棒性，<strong>Denoising Autoencoder</strong>(Vincent et al. 2008) 提出了对基本autoencoder的修改。通过以随机方式向输入向量的某些值添加噪声或掩盖输入向量的某些值来部分破坏输入，<span class="math inline">\(\tilde{\mathbf{x}} \sim \mathcal{M}_{\mathcal{D}}(\tilde{\mathbf{x}} \mid \mathbf{x})\)</span>。然后训练模型以恢复原始输入（注意：不是损坏的输入）。 <span class="math display">\[
\begin{aligned}
\tilde{\mathbf{x}}^{(i)} &amp; \sim \mathcal{M}_{\mathcal{D}}\left(\tilde{\mathbf{x}}^{(i)} \mid \mathbf{x}^{(i)}\right) \\
L_{\mathrm{DAE}}(\theta, \phi) &amp; =\frac{1}{n} \sum_{i=1}^n\left(\mathbf{x}^{(i)}-f_\theta\left(g_\phi\left(\tilde{\mathbf{x}}^{(i)}\right)\right)\right)^2
\end{aligned}
\]</span> 其中<span class="math inline">\(\mathcal{M}_{\mathcal{D}}\)</span>定义了从真实数据样本到噪声或者损坏样本的映射。</p>
<img src="/2023/04/24/19-17-24/denoising-autoencoder-architecture.png" class="" title="denoising-autoencoder-architecture">
<center>
图2. 去噪自动编码器模型结构的说明
</center>
<p>这种设计的动机是人类可以很容易地识别一个物体或场景，即使视图被部分遮挡或损坏。为了"修复 "部分被破坏的输入，denoising autoencoder码器必须发现和捕捉输入的各个维度之间的关系，以便推断出丢失的部分。</p>
<p>对于具有高冗余度的高维输入，如图像，该模型可能依赖于从许多输入维度的组合中收集的根据来恢复去噪版本，而不是过度拟合一个维度。这为学习稳健的潜在表征奠定了良好的基础。</p>
<p>噪声是由一个随机映射控制的<span class="math inline">\(\mathcal{M}_\mathcal{D}(\mathbf{\tilde{x}|x})\)</span>，而且它不是特定于某一类型的破坏过程（即掩蔽噪声、高斯噪声、盐和胡椒噪声等）。当然，破坏过程可以配备先验知识。</p>
<p>在原始DAE论文的实验中，噪声是这样应用的：随机选择固定比例的输入维度，并将其值强制为0。 听起来很像dropout，对吗？嗯，去噪自动编码器是在2008年提出的，比dropout论文早4年<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fwww.cs.toronto.edu%2F~hinton%2Fabsps%2FJMLRdropout.pdf#=&amp;zoom=130">（Hinton, et al. 2012）</a>。</p>
<h2 id="sparse-autoencoder">Sparse Autoencoder</h2>
<p><strong>Sparse Autoencoder</strong>对隐藏单元的激活应用了一个“稀疏”约束，以避免过度拟合并提高鲁棒性。它迫使模型只有少量的隐藏单元同时被激活，或者换句话说，一个隐藏神经元应该在大部分时间内不被激活。</p>
<p>回想一下，常见的激活函数包括 sigmoid、tanh、relu、leaky relu 等。当值接近 1 时激活神经元，当值接近 0 时神经元失活。</p>
<p>假设在第<span class="math inline">\(l\)</span>个隐藏层中有<span class="math inline">\(s_l\)</span>个神经元，该层中第<span class="math inline">\(j\)</span>个神经元的激活函数被标记为<span class="math inline">\(a_j^{l}(.),j=1,...,s_l\)</span>。该神经元的激活比例<span class="math inline">\(\hat{\rho_j}\)</span>应该是一个小数<span class="math inline">\(\rho\)</span>，被称为<em>稀疏参数</em>；常见的配置是<span class="math inline">\(\rho=0.05\)</span>。</p>
<p>这个公式是用来计算第<span class="math inline">\(l\)</span>个隐藏层中第<span class="math inline">\(j\)</span>个神经元的激活比例<span class="math inline">\(\hat{\rho_j}\)</span>的。它是通过对<span class="math inline">\(n\)</span>个输入样本的激活函数<span class="math inline">\(a_j^{(l)}\)</span>进行求平均得到的。其中，<span class="math inline">\(x^{(i)}\)</span>是第<span class="math inline">\(i\)</span>个输入样本，<span class="math inline">\(n\)</span>是输入样本的数量。由于这个平均值通常会近似于稀疏参数<span class="math inline">\(\rho\)</span>，因此可以用这个平均值作为<span class="math inline">\(\hat{\rho_j}\)</span>的近似值。 <span class="math display">\[
\hat{\rho}_j^l=\frac{1}{n}\sum_{i=1}^n[a_j^{(l)}x(^{(i)})]\approx\rho
\]</span> 这个约束是通过在损失函数中加入一个惩罚项来实现的。KL-散度<span class="math inline">\(D_{KL}\)</span>测量两个伯努利分布之间的差异，一个是平均值<span class="math inline">\(\rho\)</span>，另一个是平均值<span class="math inline">\(\hat{\rho}_j^{(l)}\)</span>。超参数<span class="math inline">\(\beta\)</span>控制控制我们想要对稀疏性损失应用的惩罚强度。 <span class="math display">\[
\begin{aligned}
L_{\mathrm{SAE}}(\theta) &amp; =L(\theta)+\beta \sum_{l=1}^L \sum_{j=1}^{s_l} D_{\mathrm{KL}}\left(\rho \| \hat{\rho}_j^{(l)}\right) \\
&amp; =L(\theta)+\beta \sum_{l=1}^L \sum_{j=1}^{s_l} \rho \log \frac{\rho}{\hat{\rho}_j^{(l)}}+(1-\rho) \log \frac{1-\rho}{1-\hat{\rho}_j^{(l)}}
\end{aligned}
\]</span></p>
<img src="/2023/04/24/19-17-24/KL%20divergence.png" class="" title="KL divergence">
<p><span class="math display">\[
\text{图3. 均值为}\rho=0.5\text{的伯努利分布与均值为}0\le\hat{\rho}\le1\text{的伯努利分布之间的KL散度}
\]</span></p>
<p><strong><span class="math inline">\(k-\)</span>Sparse Autoencoder</strong></p>
<p>在<strong><span class="math inline">\(k-\)</span>Sparse Autoencoder</strong><a href="https://arxiv.org/abs/1312.5663">（Makhzani和Frey，2013）</a>中，通过在具有线性激活函数的bottleneck层中只保留前<span class="math inline">\(k\)</span>个最高的激活来强制执行稀疏性。首先，我们通过编码器网络运行前馈，得到压缩后的代码： <span class="math inline">\(\mathbf{z=g(x)}\)</span>。对代码向量<span class="math inline">\(\mathbf{z}\)</span>中的值进行排序，只保留最大的<span class="math inline">\(k\)</span>个值，而其他神经元被设置为0。现在我们有了一个稀疏化的编码： <span class="math inline">\(\mathbf{z&#39;{=Sparsify(z)}}\)</span>。计算输出和稀疏化代码的损失、 <span class="math inline">\(\mathbf{L=|x-f(z&#39;)|_2^2}\)</span>。而且，反向传播只经过前<span class="math inline">\(k\)</span>个被激活的隐藏单元！</p>
<img src="/2023/04/24/19-17-24/k-sparse-autoencoder.png" class="" title="k-sparse-autoencoder">
<center>
图4. 从有1000个隐藏单元的MNIST中学习的不同稀疏度k的自动编码器的过滤器（图片来源：<a href="https://arxiv.org/abs/1312.5663">Makhzani和Frey，2013年</a>）
</center>
<h2 id="contractive-autoencoder">Contractive Autoencoder</h2>
<p>与sparse autoencoder类似，<strong>Contractive Autoencoder</strong>（<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=http%3A%2F%2Fwww.icml-2011.org%2Fpapers%2F455_icmlpaper.pdf#=&amp;zoom=130">Rifai, et al, 2011</a>）鼓励学习到的表征保持在收缩空间中，以获得更好的鲁棒性。</p>
<p>它在损失函数中增加了一个项，以惩罚对输入过于敏感的表示，从而提高对训练数据点周围的小扰动的稳健性。敏感性是由编码器激活的雅各布矩阵对输入的Frobenius准则来衡量的： <span class="math display">\[
\left\|J_f(\mathbf{x})\right\|_F^2=\sum_{i j}\left(\frac{\partial h_j(\mathbf{x})}{\partial x_i}\right)^2
\]</span> 其中<span class="math inline">\(h_j\)</span>是压缩代码 <span class="math inline">\(z=f(x)\)</span> 中的一个单元输出。</p>
<p>这个惩罚项是所学编码相对于输入维度的所有偏导数的平方之和。作者声称，根据经验，这个惩罚项被发现可以刻画出一个对应于低维非线性流形的表征，同时对流形正交的多数方向保持不变。</p>
<h2 id="vae-variational-autoencoder">VAE: Variational Autoencoder</h2>
<p>变量自动编码器（<a href="https://arxiv.org/abs/1312.6114">Kingma &amp; Welling, 2014</a>）的想法，简称VAE，实际上与上述所有自动编码器模型不太相似，但深深扎根于变分贝叶斯和图模型的方法。</p>
<p>我们不是把输入映射成一个固定的向量，而是要把它映射成一个分布。让我们把这个分布标记为<span class="math inline">\(p_\theta\)</span>，以<span class="math inline">\(\theta\)</span>为参数。数据输入<span class="math inline">\(x\)</span>和潜在编码向量<span class="math inline">\(z\)</span>之间的关系可以完全定义为：</p>
<ul>
<li><p>先验 <span class="math inline">\(p_\theta(z)\)</span></p></li>
<li><p>似然 <span class="math inline">\(p_\theta(x|z)\)</span></p></li>
<li><p>后验 <span class="math inline">\(p_\theta(z|x)\)</span></p></li>
</ul>
<p>假设我们知道这个分布的真实参数<span class="math inline">\(θ^*\)</span>。为了生成一个看起来像真实数据点<span class="math inline">\(x^{(i)}\)</span>的样本，我们遵循以下步骤：</p>
<ol type="1">
<li>首先，从先验分布<span class="math inline">\(p_{\theta^*}(z)\)</span>中采样 <span class="math inline">\(z^{(i)}\)</span>。</li>
<li>然后从条件分布 <span class="math inline">\(p_{θ^∗}(x|z=z^{(i)})\)</span> 生成值 <span class="math inline">\(x^{(i)}\)</span>。</li>
</ol>
<p>最佳参数<span class="math inline">\(θ^∗\)</span>是使生成真实数据样本的概率最大化的参数： <span class="math display">\[
\theta^*=\arg \max _\theta \prod_{i=1}^n p_\theta\left(\mathbf{x}^{(i)}\right)
\]</span> 通常我们使用对数概率将 RHS 上的乘积转换为总和： <span class="math display">\[
\theta^*=\arg \max _\theta \sum_{i=1}^n \log p_\theta\left(\mathbf{x}^{(i)}\right)
\]</span> <span class="math inline">\(p_\theta\left(\mathbf{x}^{(i)}\right)\)</span> 是在参数 <span class="math inline">\(\theta\)</span> 下生成数据点 <span class="math inline">\(\mathbf{x}^{(i)}\)</span> 的概率密度函数值。在 VAE 中，我们希望最大化所有数据点的生成概率密度函数的乘积，从而找到最优的参数 <span class="math inline">\(\theta^*\)</span>。所以，该公式就是要求最大化所有数据点的生成概率密度函数的乘积，以找到最优的参数 <span class="math inline">\(\theta^*\)</span>。</p>
<p>现在让我们更新这个方程，以更好地展示数据生成过程，从而涉及编码矢量。 <span class="math display">\[
p_\theta\left(\mathbf{x}^{(i)}\right)=\int p_\theta\left(\mathbf{x}^{(i)} \mid \mathbf{z}\right) p_\theta(\mathbf{z}) d \mathbf{z}
\]</span> 不幸的是，按照这种方式计算 <span class="math inline">\(p_\theta\left(\mathbf{x}^{(i)}\right)\)</span> 是非常昂贵的，因为要检查所有可能的 <span class="math inline">\(\mathbf{z}\)</span> 值并将它们相加。为了缩小值空间以便更快地进行搜索，我们想引入一个新的近似函数，用于输出给定输入 <span class="math inline">\(\mathbf{x}\)</span> 的可能编码，即 <span class="math inline">\(q_\phi(\mathbf{z} \mid \mathbf{x})\)</span>，由参数 <span class="math inline">\(\phi\)</span> 参数化。</p>
<img src="/2023/04/24/19-17-24/VAE-graphical-model.png" class="" title="VAE-graphical-model">
<p><span class="math display">\[
\text{图5. 变分自编码器中涉及的图形模型。实线表示生成分布}\:p_\theta(.)，\text{虚线表示后验分布}\:q_\phi(\mathbf{z}\mid \mathbf{x})\text{以近似难以计算的后验}\:p_\theta(\mathbf{z} \mid \mathbf{x})。
\]</span> 现在这个结构看起来很像一个autoencoder：</p>
<ul>
<li><p>条件概率<span class="math inline">\(p_\theta(\mathbf{x}|\mathbf{z})\)</span>定义了一个生成模型，类似于上面介绍的解码器<span class="math inline">\(f_θ(\mathbf{x|z})\)</span>。 <span class="math inline">\(p_\theta(\mathbf{x}|\mathbf{z})\)</span>也被称为概率解码器。</p></li>
<li><p>近似函数<span class="math inline">\(q_{\phi}\mathbf{(z|x)}\)</span>是概率编码器，扮演的角色与上述<span class="math inline">\(g_\phi(\mathbf{z|x})\)</span>类似。</p></li>
</ul>
<h2 id="loss-function-elbo">Loss Function: ELBO</h2>
<p>估计的后验<span class="math inline">\(q_\phi(\mathbf{z|x})\)</span>应该非常接近实际的<span class="math inline">\(p_\theta(\mathbf{z|x})\)</span>。我们可以用Kullback-Leibler散度来量化这两个分布之间的距离。KL散度<span class="math inline">\(D_{KL}(X|Y)\)</span>衡量如果用分布Y来表示X，会损失多少信息。</p>
<p>在我们的例子中，我们想要最小化关于<span class="math inline">\(\phi\)</span> 的<span class="math inline">\(D_{KL}(q_\phi(\mathbf{z|x})\mid p_\theta(\mathbf{z|x}))\)</span>。</p>
<p>但为什么要使用<span class="math inline">\(D_{KL}(q_\phi|p_\theta)\)</span>（反向KL）而不是<span class="math inline">\(D_{KL}(p_\theta|q_\phi)\)</span>（前向KL）？Eric Jang在他关于贝叶斯变异方法的<a href="https://blog.evjang.com/2016/08/variational-bayes.html">文章</a>中有一个很好的解释。快速回顾一下:</p>
<img src="/2023/04/24/19-17-24/forward_vs_reversed_KL.png" class="" title="forward_vs_reversed_KL">
<center>
图6. 正向和反向的KL发散对如何匹配两个分布有不同的要求。(图片来源：blog.evjang.com/2016/08/variational-bayes.html)
</center>
<p>前向 <span class="math inline">\(\mathrm{KL}\)</span> 散度: <span class="math inline">\(D_{\mathrm{KL}}(P \mid Q)=\mathbb{E}_{z \sim P(z)} \log \frac{P(z)}{Q(z)}\)</span>; 我们必须确保 <span class="math inline">\(\mathrm{P}(\mathrm{z})&gt;0\)</span>时<span class="math inline">\(\mathrm{Q}(\mathrm{z})&gt;0\)</span>。优化后的变分分布<span class="math inline">\(q(z)\)</span>必须覆盖整个 <span class="math inline">\(p(z)\)</span>。</p>
<p>反向<span class="math inline">\(\mathrm{KL}\)</span> 散度: <span class="math inline">\(D_{\mathrm{KL}}(Q \mid P)=\mathbb{E}_{z \sim Q(z)} \log \frac{Q(z)}{P(z)} ;\)</span> 最小化反向 KL 散度会让 <span class="math inline">\(Q(z)\)</span> 的分布逐渐靠近并受限于 <span class="math inline">\(P(z)\)</span> 的分布</p>
<p>现在让我们扩展方程： <span class="math display">\[
\begin{aligned}
&amp; D_\text{KL}( q_\phi(\mathbf{z}\vert\mathbf{x}) \mid p_\theta(\mathbf{z}\vert\mathbf{x}) ) &amp; \\
&amp;=\int q_\phi(\mathbf{z} \vert \mathbf{x}) \log\frac{q_\phi(\mathbf{z} \vert \mathbf{x})}{p_\theta(\mathbf{z} \vert \mathbf{x})} d\mathbf{z} &amp; \\
&amp;=\int q_\phi(\mathbf{z} \vert \mathbf{x}) \log\frac{q_\phi(\mathbf{z} \vert \mathbf{x})p_\theta(\mathbf{x})}{p_\theta(\mathbf{z}, \mathbf{x})} d\mathbf{z} &amp; \scriptstyle{\text{; Because }p(z \vert x) = p(z, x) / p(x)} \\
&amp;=\int q_\phi(\mathbf{z} \vert \mathbf{x}) \big( \log p_\theta(\mathbf{x}) + \log\frac{q_\phi(\mathbf{z} \vert \mathbf{x})}{p_\theta(\mathbf{z}, \mathbf{x})} \big) d\mathbf{z} &amp; \\
&amp;=\log p_\theta(\mathbf{x}) + \int q_\phi(\mathbf{z} \vert \mathbf{x})\log\frac{q_\phi(\mathbf{z} \vert \mathbf{x})}{p_\theta(\mathbf{z}, \mathbf{x})} d\mathbf{z} &amp; \scriptstyle{\text{; Because }\int q(z \vert x) dz = 1}\\
&amp;=\log p_\theta(\mathbf{x}) + \int q_\phi(\mathbf{z} \vert \mathbf{x})\log\frac{q_\phi(\mathbf{z} \vert \mathbf{x})}{p_\theta(\mathbf{x}\vert\mathbf{z})p_\theta(\mathbf{z})} d\mathbf{z} &amp; \scriptstyle{\text{; Because }p(z, x) = p(x \vert z) p(z)} \\
&amp;=\log p_\theta(\mathbf{x}) + \mathbb{E}_{\mathbf{z}\sim q_\phi(\mathbf{z} \vert \mathbf{x})}[\log \frac{q_\phi(\mathbf{z} \vert \mathbf{x})}{p_\theta(\mathbf{z})} - \log p_\theta(\mathbf{x} \vert \mathbf{z})] &amp;\\
&amp;=\log p_\theta(\mathbf{x}) + D_\text{KL}(q_\phi(\mathbf{z}\vert\mathbf{x}) \| p_\theta(\mathbf{z})) - \mathbb{E}_{\mathbf{z}\sim q_\phi(\mathbf{z}\vert\mathbf{x})}\log p_\theta(\mathbf{x}\vert\mathbf{z}) &amp;
\end{aligned}
\]</span> 方程的LHS正是我们在学习真实分布时想要最大化的东西：我们想要最大化产生真实数据的（对数）可能性（也就是<span class="math inline">\(logp_{\theta}(x)\)</span>），同时最小化真实分布和估计后验分布之间的差异（术语<span class="math inline">\(D_{KL}\)</span>的作用就像一个正则器）。请注意，<span class="math inline">\(p_{θ}(x)\)</span>相对于<span class="math inline">\(q_\phi\)</span>是固定的。</p>
<p>上述的负数定义了我们的损失函数： <span class="math display">\[
\begin{aligned}
L_{\mathrm{VAE}}(\theta, \phi) &amp; =-\log p_\theta(\mathbf{x})+D_{\mathrm{KL}}\left(q_\phi(\mathbf{z} \mid \mathbf{x}) \| p_\theta(\mathbf{z} \mid \mathbf{x})\right) \\
&amp; =-\mathbb{E}_{\mathbf{z} \sim q \phi(\mathbf{z} \mid \mathbf{x})} \log p_\theta(\mathbf{x} \mid \mathbf{z})+D_{\mathrm{KL}}\left(q_\phi(\mathbf{z} \mid \mathbf{x}) \| p_\theta(\mathbf{z})\right) \\
\theta^*, \phi^* &amp; =\arg \min _{\theta, \phi} L_{\mathrm{VAE}}
\end{aligned}
\]</span> 在变分贝叶斯方法中，这种损失函数被称为变分下界或evidence下界。名称中的“下界”部分来自 KL 散度始终为非负的事实，因此$ −L_{VAE}$ 是 <span class="math inline">\(logp_θ(x)\)</span> 的下界。</p>
<p><span class="math display">\[
-L_{\mathrm{VAE}}=\log p_\theta(\mathbf{x})-D_{\mathrm{KL}}\left(q_\phi(\mathbf{z} \mid \mathbf{x}) \| p_\theta(\mathbf{z} \mid \mathbf{x})\right) \leq \log p_\theta(\mathbf{x})
\]</span> 这句话中，"variational lower bound" 指的是变分下界或evidence下界，即能够被用来估计模型生成的样本与真实样本之间差异的指标。"KL divergence is always non-negative" 表示 KL 散度总是非负数。因此，<span class="math inline">\(-L_{\mathrm{VAE}}\)</span> 的值就是 <span class="math inline">\(\log p_\theta(\mathbf{x})\)</span> 的下界，这意味着我们可以使用 <span class="math inline">\(-L_{\mathrm{VAE}}\)</span> 来估计 <span class="math inline">\(\log p_\theta(\mathbf{x})\)</span>，并且保证得到的结果不会低于实际值。</p>
<h2 id="reparameterization-trick">Reparameterization Trick</h2>
<p>损失函数中的期望项涉及从<span class="math inline">\(\mathbf{z} \sim q_\phi(\mathbf{z} \mid \mathbf{x})\)</span>生成样本 。采样是一种随机过程，因此我们无法反向传播梯度。为了使其可训练，引入了重参数化技巧：通常可以将随机变量 <span class="math inline">\(\mathbf{z}\)</span> 表示为一个确定性变量 <span class="math inline">\(\mathbf{z}=\mathcal{T}_\phi(\mathbf{x}, \boldsymbol{\epsilon})\)</span>，其中 <span class="math inline">\(\boldsymbol{\epsilon}\)</span> 是一个辅助的独立随机变量，由 <span class="math inline">\(\phi\)</span> 参数化的变换函数 <span class="math inline">\(\mathcal{T}_\phi\)</span> 将 <span class="math inline">\(\boldsymbol{\epsilon}\)</span> 转换为 <span class="math inline">\(\mathbf{z}\)</span>。</p>
<p>例如，<span class="math inline">\(q_\phi(\mathbf{z} \mid \mathbf{x})\)</span> 的常见选择是具有对角协方差结构的多元高斯分布： <span class="math display">\[
\begin{align}
&amp;\mathbf{z} \sim q_\phi\left(\mathbf{z} \mid \mathbf{x}^{(i)}\right)=\mathcal{N}\left(\mathbf{z} ; \boldsymbol{\mu}^{(i)}, \boldsymbol{\sigma}^{2(i)} \boldsymbol{I}\right)\\
&amp;\mathbf{z}=\boldsymbol{\mu}+\boldsymbol{\sigma} \odot \boldsymbol{\epsilon}, where\:\boldsymbol{\epsilon} \sim \mathcal{N}(0, \boldsymbol{I}) \quad ; Reparameterization\:trick.
\end{align}
\]</span> 其中 <span class="math inline">\(\odot\)</span> 表示逐元素相乘。</p>
<img src="/2023/04/24/19-17-24/reparameterization-trick.png" class="" title="reparameterization-trick">
<p><span class="math display">\[
\text{图7. 说明了重新参数化技巧如何使得}\mathbf{z}\text{采样过程可训练。(图片来源：Kingma在NIPS 2015研讨会上的幻灯片第12页)}
\]</span> <img src="/2023/04/24/19-17-24/vae-gaussian.png" class="" title="vae-gaussian"> <span class="math display">\[
\text{图8. 具有多元高斯假设的variational autoencoder模型的图示}
\]</span></p>
<p>编码步骤：</p>
<ol type="1">
<li>将 <span class="math inline">\(\mathbf{x}\)</span> 通过编码器 <span class="math inline">\(q_{\phi}(\mathbf{z} \mid \mathbf{x})\)</span> 转化为潜在空间中的分布参数，即 <span class="math inline">\(\mu_{\phi}(\mathbf{x})\)</span> 和 <span class="math inline">\(\log \sigma^2_{\phi}(\mathbf{x})\)</span>。</li>
<li>从标准正态分布<span class="math inline">\(\mathcal{N}(0, \boldsymbol{I})\)</span>中采样噪声 <span class="math inline">\(\mathbf{\epsilon}\)</span>。</li>
<li>使用重参数技巧，将采样的噪声 <span class="math inline">\(\mathbf{\epsilon}\)</span> 与分布参数 <span class="math inline">\(\mu_{\phi}(\mathbf{x})\)</span> 和 <span class="math inline">\(\sigma_{\phi}(\mathbf{x})\)</span> 结合，得到 <span class="math inline">\(\mathbf{z} = \mu_{\phi}(\mathbf{x}) + \sigma_{\phi}(\mathbf{x}) \odot \mathbf{\epsilon}\)</span>，其中 <span class="math inline">\(\odot\)</span> 表示元素级别的乘法。</li>
<li>最终得到的 <span class="math inline">\(\mathbf{z}\)</span> 即为从数据 <span class="math inline">\(\mathbf{x}\)</span> 中提取的隐变量。</li>
</ol>
<p>需要注意的是，在第三步使用重参数技巧是为了将采样过程转化为可微分的操作，这样可以通过反向传播算法优化模型参数。</p>
<p>在编码器中，通常会使用神经网络将输入 <span class="math inline">\(\mathbf{x}\)</span> 映射到潜在空间中的分布参数 <span class="math inline">\(\mu_{\phi}(\mathbf{x})\)</span> 和 <span class="math inline">\(\log \sigma^2_{\phi}(\mathbf{x})\)</span>。具体来说，输入 <span class="math inline">\(\mathbf{x}\)</span> 会经过多层神经网络的计算，最终得到均值向量 <span class="math inline">\(\mu_{\phi}(\mathbf{x})\)</span> 和方差向量 <span class="math inline">\(\sigma^2_{\phi}(\mathbf{x})\)</span>。由于 <span class="math inline">\(\sigma^2_{\phi}(\mathbf{x})\)</span> 需要保证是正数，因此一般会将神经网络输出的 <span class="math inline">\(\sigma^2_{\phi}(\mathbf{x})\)</span> 进行非负化处理，例如通过取指数等方式，再加上一个很小的正数，以保证不会出现零方差。最终得到的是 <span class="math inline">\(\log \sigma^2_{\phi}(\mathbf{x})\)</span>。这样就可以得到潜在分布的均值和方差，从而生成随机样本 <span class="math inline">\(\mathbf{z}\)</span>。</p>
<h2 id="beta-vae">Beta-VAE</h2>
<p>如果推断得到的潜在表示 <span class="math inline">\(\mathbf{z}\)</span> 中的每个变量只对一个单独的生成因子敏感，而对其他因子相对不变，那么我们会说这个表示是分离的或因子化的。分离的表示通常具有良好的可解释性，并且易于推广到各种任务中。</p>
<p>例如，对于人脸照片训练的模型可能会在单独的维度中捕捉到肤色、头发颜色、头发长度、情绪、是否戴眼镜等许多相对独立的因素。这样的分离表示对于人脸图像生成非常有益。</p>
<p><span class="math inline">\(\beta\)</span>-VAE (Higgins et al., 2017) 是变分自编码器的一种修改，特别强调发现分离的潜在因子。与 <span class="math inline">\(\mathrm{VAE}\)</span> 中的相同激励一样，我们希望最大化生成真实数据的概率，同时保持真实后验分布与估计后验分布之间的距离很小（例如，小于一个常量 <span class="math inline">\(\delta\)</span>）： <span class="math display">\[
\begin{aligned}
&amp; \max _{\phi, \theta} \mathbb{E}_{\mathbf{x} \sim \mathcal{D}}\left[\mathbb{E}_{\mathbf{z} \sim q \phi(\mathbf{z} \mid \mathbf{x})} \log p_\theta(\mathbf{x} \mid \mathbf{z})\right] \\
&amp; \text { subject to } D_{\mathrm{KL}}\left(q_\phi(\mathbf{z} \mid \mathbf{x}) \| p_\theta(\mathbf{z})\right)&lt;\delta
\end{aligned}
\]</span> 我们可以在 KKT 条件下使用拉格朗日乘子 <span class="math inline">\(\beta\)</span> 重新表述它。只有一个不等式约束的上述优化问题等价于最大化以下方程 <span class="math inline">\(\mathcal{F}(\theta, \phi, \beta)\)</span>： <span class="math display">\[
\begin{array}{rlr}
\mathcal{F}(\theta, \phi, \beta) &amp; =\mathbb{E}_{\mathbf{z} \sim q_\phi(\mathbf{z} \mid \mathbf{x})} \log p_\theta(\mathbf{x} \mid \mathbf{z})-\beta\left(D_{\mathrm{KL}}\left(q_\phi(\mathbf{z} \mid \mathbf{x}) \| p_\theta(\mathbf{z})\right)-\delta\right) \\
&amp; =\mathbb{E}_{\mathbf{z} \sim q \phi(\mathbf{z} \mid \mathbf{x})} \log p_\theta(\mathbf{x} \mid \mathbf{z})-\beta D_{\mathrm{KL}}\left(q_\phi(\mathbf{z} \mid \mathbf{x}) \| p_\theta(\mathbf{z})\right)+\beta \delta &amp; \\
&amp; \geq \mathbb{E}_{\mathbf{z} \sim q_\phi(\mathbf{z} \mid \mathbf{x})} \log p_\theta(\mathbf{x} \mid \mathbf{z})-\beta D_{\mathrm{KL}}\left(q_\phi(\mathbf{z} \mid \mathbf{x}) \| p_\theta(\mathbf{z})\right) \quad ; \text { Because } \beta, \delta \geq 0
\end{array}
\]</span> <span class="math inline">\(\beta\)</span>-VAE 的损失函数定义如下： <span class="math display">\[
L_{\mathrm{BETA}}(\phi, \beta)=-\mathbb{E}*{\mathbf{z} \sim q*\phi(\mathbf{z} \mid \mathbf{x})} \log p_\theta(\mathbf{x} \mid \mathbf{z})+\beta D_{\mathrm{KL}}\left(q_\phi(\mathbf{z} \mid \mathbf{x}) | p_\theta(\mathbf{z})\right)
\]</span> 在这里，拉格朗日乘子<span class="math inline">\(\beta\)</span>被视为超参数。由于<span class="math inline">\(L_{\mathrm{BETA}}(\phi, \beta)\)</span>的否定是拉格朗日函数<span class="math inline">\(\mathcal{F}(\theta, \phi, \beta)\)</span>的下界，因此最小化损失等价于最大化拉格朗日函数，从而适用于我们最初的优化问题。当<span class="math inline">\(\beta=1\)</span>时，它与VAE相同。当<span class="math inline">\(\beta&gt;1\)</span>时，它对潜在bottleneck施加了更强的约束，并限制了<span class="math inline">\(\mathbf{z}\)</span>的表示能力。对于某些条件独立的生成因子，保持它们分离是最有效的表示方法。因此，较高的<span class="math inline">\(\beta\)</span>鼓励更有效的潜在编码，并进一步鼓励解耦。同时，较高的<span class="math inline">\(\beta\)</span>可能会在重构质量和解耦程度之间产生权衡。<a href="chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Farxiv.org%2Fpdf%2F1804.03599.pdf#=&amp;zoom=130">Burgess等人（2017）</a>深入讨论了<span class="math inline">\(\beta\)</span>-VAE中的解耦，并受信息瓶颈理论的启发，进一步提出了一种修改方法以更好地控制编码表示能力。</p>
<h2 id="vq-vae-and-vq-vae-2">VQ-VAE and VQ-VAE-2</h2>
<p>VQ-VAE（"Vector Quantised-Variational AutoEncoder"）模型通过编码器学习离散的潜在变量，因为对于语言、语音、推理等问题，离散表示可能更自然地适用。</p>
<p>向量量化（VQ）是一种将<span class="math inline">\(K\)</span>维向量映射到有限的“码”向量集合中的方法。该过程非常类似于 <span class="math inline">\({KNN}\)</span> 算法。样本应映射到的最优质心码向量是欧几里得距离最小的向量。</p>
<p>设 <span class="math inline">\(\mathbf{e} \in \mathbb{R}^{K \times D}\)</span>，<span class="math inline">\(i=1, \ldots, K\)</span> 为 VQ-VAE 中的潜在嵌入空间（也称为“码本”），其中 <span class="math inline">\(K\)</span> 是潜在变量类别的数量，<span class="math inline">\(D\)</span> 是嵌入大小。单个嵌入向量是 <span class="math inline">\(\mathbf{e}_i \in \mathbb{R}^D\)</span>，<span class="math inline">\(i=1, \ldots, K\)</span>。</p>
<p>编码器的输出 <span class="math inline">\(E(\mathbf{x})=\mathbf{z}_e\)</span> 经过最近邻查找以匹配 <span class="math inline">\(K\)</span> 个嵌入向量之一，然后匹配的码向量成为解码器的输入 <span class="math inline">\(D(\)</span>.<span class="math inline">\() :\)</span></p>
<p><span class="math inline">\(\mathbf{z}_q(\mathbf{x})=\)</span> Quantize <span class="math inline">\((E(\mathbf{x}))=\mathbf{e}_k\)</span> ，<span class="math inline">\(k=\arg \min _i\left\|E(\mathbf{x})-\mathbf{e}_i\right\|_2\)</span></p>
<p>请注意，在不同的应用程序中，离散潜在变量的形状可能不同；例如，语音为1D，图像为2D，视频为3D。</p>
<img src="/2023/04/24/19-17-24/VQ-VAE.png" class="" title="VQ-VAE">
<center>
图9. VQ-VAE 的架构（图片来源：van den Oord, et al. 2017）
</center>
<p>由于 argmin() 在离散空间上是不可微的，因此从解码器输入 <span class="math inline">\(\mathbf{z}_q\)</span> 到编码器输出 <span class="math inline">\(\mathbf{z}_e\)</span> 的梯度 <span class="math inline">\(\nabla_z L\)</span> 被复制。除了重构损失之外，VQ-VAE 还优化以下内容：</p>
<ul>
<li><span class="math inline">\(V Q\)</span> 损失：嵌入空间和编码器输出之间的 L2 误差。</li>
<li>承诺损失：一种鼓励编码器输出保持接近嵌入空间的度量，以防止其从一个码向量频繁波动到另一个码向量。</li>
</ul>
<p><span class="math inline">\(L=\underbrace{\left\|\mathbf{x}-D\left(\mathbf{e}_k\right)\right\|_2^2}_{\text {reconstruction loss }}+\underbrace{\| \operatorname{sg}[E(\mathbf{x})]}_{\text {vQ loss }}-\mathbf{e}_k \|_2^2+\underbrace{\beta\left\|(\mathbf{x})-\operatorname{sg}\left[\mathbf{e}_k\right]\right\|_2^2}_{\text {commitment loss }}\)</span></p>
<p>其中 <span class="math inline">\(\mathrm{sq}[.]\)</span> 是 <code>stop_gradient</code>运算符。</p>
<p>codebook 中的embedding vectors通过 EMA（指数移动平均）进行更新。给定一个code vector<span class="math inline">\(\mathbf{e}_i\)</span>，假设我们有 <span class="math inline">\(n_i\)</span> 个编码器输出向量<span class="math inline">\(\left\{\mathbf{z}_{i, j}\right\}_{j=1}^{n_i}\)</span>，它们被量化为 <span class="math inline">\(\mathbf{e}_i\)</span>： <span class="math display">\[
N_i^{(t)}=\gamma N_i^{(t-1)}+(1-\gamma) n_i^{(t)} \quad \mathbf{m}_i^{(t)}=\gamma \mathbf{m}_i^{(t-1)}+(1-\gamma) \sum_{j=1}^{n_i^{(t)}} \mathbf{z}_{i, j}^{(t)} \quad \mathbf{e}_i^{(t)}=\mathbf{m}_i^{(t)} / N_i^{(t)}
\]</span> 其中 <span class="math inline">\((t)\)</span> 指时间序列批次。<span class="math inline">\(N_i\)</span> 和 <span class="math inline">\(\mathbf{m}_i\)</span> 分别是累积向量计数和体积。</p>
<p>VQ-VAE-2（<a href="https://arxiv.org/abs/1906.00446">Ali Razavi 等，2019</a>）是一个两级分层的 VQ-VAE，与自注意力自回归模型结合</p>
<ol type="1">
<li>第 1 阶段是<strong>训练分层 VQ-VAE</strong>：分层潜变量的设计旨在将局部模式（例如纹理）与全局信息（例如对象形状）分离。更大的底层codebook 的训练受到更小的顶层码的限制，这样就不必从头开始学习所有内容。</li>
<li>第2阶段是<strong>学习一个先验分布</strong>，使我们可以从中采样并生成图像。这样，解码器可以接收从训练中采样的类似分布的输入向量。使用一个强大的自回归模型，增强了多头自注意力层来捕捉先验分布（例如<a href="https://arxiv.org/abs/1712.09763">PixelSNAIL；Chen等人，2017</a>）。</li>
</ol>
<p>考虑到VQ-VAE-2取决于在简单的分层设置中配置的离散潜在变量，它生成的图像质量非常惊人。</p>
<img src="/2023/04/24/19-17-24/VQ-VAE-2.png" class="" title="VQ-VAE-2">
<center>
图10.分层VQ-VAE和多阶段图像生成的架构。(图片来源：Ali Razavi, et al. 2019)
</center>
<img src="/2023/04/24/19-17-24/VQ-VAE-2-algo.png" class="" title="VQ-VAE-2-algo">
<center>
图11. VQ-VAE-2算法。(图片来源：Ali Razavi, et al. 2019)
</center>
<h2 id="td-vae">TD-VAE</h2>
<p>TD-VAE (“Temporal Difference VAE”; <a href="https://arxiv.org/abs/1806.03107">Gregor et al., 2019</a>)适用于连续的数据。它依赖于三个主要想法，描述如下。</p>
<img src="/2023/04/24/19-17-24/TD-VAE-state-space.png" class="" title="TD-VAE-state-space">
<center>
图12. 马尔可夫链模型的状态空间模型。
</center>
<p><strong>1. 状态空间模型 </strong></p>
<p>在（潜在的）状态空间模型中，一系列未观察到的隐藏状态<span class="math inline">\(\mathbf{z}=\left(z_1, \ldots, z_T\right)\)</span>确定了观测状态<span class="math inline">\(\mathbf{x}=\left(x_1, \ldots, x_T\right)\)</span>。在图13中的马尔可夫链模型中，与图6中类似，可以通过将难以处理的后验<span class="math inline">\(p(z \mid x)\)</span>近似为一个函数<span class="math inline">\(q(z \mid x)\)</span>来训练每个时间步。</p>
<p><strong>2. 信念状态</strong> 一个智能体应该学会编码所有过去的状态以便推断未来，这被称为信念状态，<span class="math inline">\(b_t=\operatorname{belief}\left(x_1, \ldots, x_t\right)=\)</span> belief <span class="math inline">\(f\left(b_{t-1}, x_t\right)\)</span>。有了这个，将未来状态的分布条件化于过去就可以写成<span class="math inline">\(p\left(x_{t+1}, \ldots, x_T \mid x_1, \ldots, x_t\right) \approx p\left(x_{t+1}, \ldots, x_T \mid b_t\right)\)</span>。在递归策略中，隐藏状态被用作TD-VAE中智能体的信念状态，因此<span class="math inline">\(b_t=\operatorname{RNN}\left(b_{t-1}, x_t\right)\)</span>。</p>
<p><strong>3. 跳跃式预测 </strong> 此外，智能体应该能够基于迄今为止收集的所有信息来想象远期，这表明具有跳跃式预测能力，即预测未来几步的状态。</p>
<p>回顾以上方差下界的内容： <span class="math display">\[
\begin{aligned}
\log p(x) &amp; \geq \log p(x)-D_{\mathrm{KL}}(q(z \mid x) \| p(z \mid x)) \\
&amp; =\mathbb{E}_{z \sim q} \log p(x \mid z)-D_{\mathrm{KL}}(q(z \mid x) \| p(z)) \\
&amp; =\mathbb{E}_{z \sim q} \log p(x \mid z)-\mathbb{E}_{z \sim q} \log \frac{q(z \mid x)}{p(z)} \\
&amp; =\mathbb{E}_{z \sim q}[\log p(x \mid z)-\log q(z \mid x)+\log p(z)] \\
&amp; =\mathbb{E}_{z \sim q}[\log p(x, z)-\log q(z \mid x)] \\
\log p(x) &amp; \geq \mathbb{E}_{z \sim q}[\log p(x, z)-\log q(z \mid x)]
\end{aligned}
\]</span> 现在让我们将状态<span class="math inline">\(x_t\)</span>的分布建模为一个概率函数，条件为所有过去的状态<span class="math inline">\(x_{&lt;t}\)</span>和当前时间步和上一步的两个潜在变量<span class="math inline">\(z_t\)</span>和<span class="math inline">\(z_{t-1}\)</span>： <span class="math display">\[
\log p\left(x_t \mid x_{&lt;t}\right) \geq \mathbb{E}_{(z t-1, z t) \sim q}\left[\log p\left(x_t, z_{t-1}, z_t \mid x_{&lt;t}\right)-\log q\left(z_{t-1}, z_t \mid x_{\leq t}\right)\right]
\]</span> 继续扩展方程： <span class="math display">\[
\begin{aligned}
&amp; \log p\left(x_t \mid x_{&lt;t}\right) \\
&amp; \geq \mathbb{E}_{(z t-1, z t) \sim q}\left[\log p\left(x_t, z_{t-1}, z_t \mid x_{&lt;t}\right)-\log q\left(z_{t-1}, z_t \mid x_{\leq t}\right)\right] \\
&amp; \geq \mathbb{E}_{\left(z_{t-1}, z_t\right) \sim q}\left[\log p\left(x_t \mid z_{t-1}, z_t, x_{&lt;t}\right)+\log p\left(z_{t-1}, z_t \mid x_{&lt;t}\right)-\log q\left(z_{t-1}, z_t \mid x_{\leq t}\right)\right] \\
&amp; \geq \mathbb{E}_{(z t-1, z t) \sim q}\left[\log p\left(x_t \mid z_t\right)+\log p\left(z_{t-1} \mid x_{&lt;t}\right)+\log p\left(z_t \mid z_{t-1}\right)-\log q\left(z_{t-1}, z_t \mid x_{\leq t}\right)\right] \\
&amp; \geq \mathbb{E}_{(z t-1, z t) \sim q}\left[\log p\left(x_t \mid z_t\right)+\log p\left(z_{t-1} \mid x_{&lt;t}\right)+\log p\left(z_t \mid z_{t-1}\right)-\log q\left(z_t \mid x_{\leq t}\right)-\log q\left(z_{t-1} \mid z_t, x_{\leq t}\right)\right]
\end{aligned}
\]</span> 注意三点：</p>
<ul>
<li><p>根据马尔可夫假设，<span style="color:red">红色</span>的项可以忽略。</p></li>
<li><p>根据马尔可夫假设，<span style="color:blue">蓝色</span>蓝色的项进行了展开。</p></li>
<li><p><span style="color:green">绿色</span>的项进行了展开，包括了向过去进行一个步长预测的平滑分布。</p></li>
</ul>
<p>准确地说，有四种类型的分布需要学习：</p>
<ol type="1">
<li><span class="math inline">\(p_D(\)</span>.) 是<strong>decoder</strong> distribution：</li>
</ol>
<ul>
<li><span class="math inline">\(p\left(x_t \mid z_t\right)\)</span> 是通常定义下的编码器；</li>
<li><span class="math inline">\(p\left(x_t \mid z_t\right) \rightarrow p_D\left(x_t \mid z_t\right)\)</span>；</li>
</ul>
<ol start="2" type="1">
<li><span class="math inline">\(p_T(\)</span>.) 是<strong>transition</strong> distribution：</li>
</ol>
<ul>
<li><span class="math inline">\(p\left(z_t \mid z_{t-1}\right)\)</span> 捕捉潜变量之间的时序依赖关系；</li>
<li><span class="math inline">\(p\left(z_t \mid z_{t-1}\right) \rightarrow p_T\left(z_t \mid z_{t-1}\right)\)</span>；</li>
</ul>
<ol start="3" type="1">
<li><span class="math inline">\(p_B(\)</span>.$) 是<strong>belief</strong> distribution：</li>
</ol>
<ul>
<li><span class="math inline">\(p\left(z_{t-1} \mid x_{&lt;t}\right)\)</span> 和 <span class="math inline">\(q\left(z_t \mid x_{\leq t}\right)\)</span> 都可以使用置信状态来预测潜变量；</li>
<li><span class="math inline">\(p\left(z_{t-1} \mid x_{&lt;t}\right) \rightarrow p_B\left(z_{t-1} \mid b_{t-1}\right)\)</span>；</li>
<li><span class="math inline">\(q\left(z_t \mid x_{\leq t}\right) \rightarrow p_B\left(z_t \mid b_t\right)\)</span>；</li>
</ul>
<ol start="4" type="1">
<li><span class="math inline">\(p_S(\)</span>.$) 是<strong>smoothing</strong> distribution：</li>
</ol>
<ul>
<li>可以将回溯到过去的平滑项 <span class="math inline">\(q\left(z_{t-1} \mid z_t, x_{\leq t}\right)\)</span> 重新写成依赖于belief状态的形式；</li>
<li><span class="math inline">\(q\left(z_{t-1} \mid z_t, x_{\leq t}\right) \rightarrow p_S\left(z_{t-1} \mid z_t, b_{t-1}, b_t\right)\)</span>；</li>
</ul>
<p>为了结合跳跃预测的思想，顺序 ELBO 不仅要对$ t<span class="math inline">\(,\)</span>t+1$起作用，还要对两个相距较远的时间戳 $t_1t_2 $起作用。这是要最大化的最终 TD-VAE 目标函数： <span class="math display">\[
J_{t_1, t_2}=\mathbb{E}\left[\log p_D\left(x_{t_2} \mid z_{t_2}\right)+\log p_B\left(z_{t_1} \mid b_{t_1}\right)+\log p_T\left(z_{t_2} \mid z_{t_1}\right)-\log p_B\left(z_{t_2} \mid b_{t_2}\right)-\log p_S\left(z_{t_1} \mid z_{t_2}, b_{t_1}, b_{t_2}\right)\right]
\]</span></p>
<img src="/2023/04/24/19-17-24/TD-VAE.png" class="" title="TD-VAE">
<center>
图13. TD-VAE 架构的详细概述，做得非常好。（图片来源：<a href="https://arxiv.org/abs/1806.03107">TD-VAE论文</a>）
</center>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>生成模型</tag>
      </tags>
  </entry>
</search>
